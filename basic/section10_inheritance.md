# 상속
## 상속 관계
기존 클래스의 필드와 메서드를 새로운 클래스에서 재사용하게 해준다.

- 부모 클래스 (슈퍼 클래스) : 상속을 통해 자신의 필드와 메서드를 다른 클래스에 제공하는 클래스
- 자식 클래스 (서브 클래스) : 부모 클래스로부터 필드와 메서드를 상속받는 클래스

    > 자식은 부모를 알고 있지만, 부모는 자식에 대해 잘 모른다.
    > 화살표의 방향은 이러한 인지 방향이라 생각해도 됨
    > 자식은 부모 기능에 접근 가능하지만, 부모는 자식의 기능을 물려 받을 수 없다.

> **다이아몬드 문제**
> 
> 자바는 다중 상속을 지원하지 않는다.  
즉, 부모는 하나만 가질 수 있다. 부모가 또 다른 부모를 하나 가지는 것은 괜찮다.
만약 다중 상속을 하게 된다면, 어떤 부모의 기능을 사용해야할지 애매해진다.  
다중 상속은 클래스 계층 구조를 매우 복잡하게 만들 수 있다.  
>
>이런 문제로 자바에서는 **인터페이스**로 다중 구현을 해결한다.

### 상속과 기능
부모에게 기능을 추가하면 모든 자식은 공통으로 해당 기능이 추가되는 것과 다름 없다.
모든 자식에게 공통으로 필요한 기능이 있다면 부모에게 구현하는 것이 효율적이다.

이러한 상속관계를 통해 중복은 줄어들고, 새로운 객체를 편리하게 확장(extend)할 수 있다.

## 상속과 메모리 구조

**상속이 있는 자식을 호출하면, 해당 참조값에 부모 인스턴스가 같이 생성된다.**  
실제로는 부모의 필드와 메서드만 물려받는 것이 아니다! 상속 관계를 사용하면 부모 클래스도 함께 포함해서 생성된다.  
```java
public class ElectricCar extend Car {
  public charge();
  
//  @Override
//  public move(); // 부모 메서드이나 자식에게는 구현하지 않은 상태
}
```
해당 참조값에는 부모와 자식이 모두 존재하고, 부모인 ```Car```를 통해서 ```charge()```를 찾을 지 아니면 ```ElectricCar```를 통해서 찾을지 선택해야 한다.
이때는 호출하는 변수의 타입(클래스)를 기준으로 선택한다.
- ```electricCar.charge()```를 호출하면 같은 타입인 ```ElectricCar```를 통해서  ```charge()```를 호출하게 된다.
- ```electricCar.move()```를 호출하였을 때, 자식 ```ElectricCar```에 없다면 부모 ```Car```에 올라가서 찾는다.  

만약 부모에서도 찾지 못하면, 더 상위 부모를 조회한다. 부모로 계속 올라가면서 찾아도 없다면 컴파일 오류가 발생한다.


## 메서드 오버라이딩
부모에게 상속 받은 기능을 자식이 재정의 하는 것.  
```@Overrride``` 어노테이션을 반드시 붙여서 상속 메서드를 정확하게 사용할 수 있도록 해준다.  
자바 컴파일러나 어노테이션을 확인하고 정확하게 오버라이드되었는지 판단해준다.
(참고로 필수는 아니지만 명확성을 위해 붙여주는 것이 좋다.)

### 오버라이딩과 오버로딩
- 오버로딩 : 메서드 이름이 같고 매개변수가 다른 메서드를 여러개 정의하는 것
- 오버라이딩 : 하위 클래스에서 상위 클래스의 기능을 **재정의**하는 것. (자식이 부모 기능의 넘어 타버림)

### 오버라이딩 조건
- 메서드 이름, 파라미터(타입, 순서) 모두 동일
- 반환 타입 동일 (단 반환 타입이 하위 클래스 타입일 수 있다.)
- 접근 제어자
  - 반드시 상위 클래스의 메서드보다 더 제한적일 수 없다.
  - 상위가 protected 이면 하위에서 private  / default 불가능
- 예외
  - 부모보다 더 많은 예외를 선언할 수 없다.
- static, final, private 키워드는 오버라이딩 할 수 없다.
- 생성자는 오버라이딩 할 수 없다.

### 상속과 접근 제어
본인 타입에서 없으면 부모에서 찾는데, 이때 접근 제어자가 영향을 준다.  
객체 내부에서는 자식과 부모가 구분되어 있기 때문이다. 자식이 부모 기능을 호출한다는 것은 사실 부모 입장에서는 외부에서 호출한 것과 같다.


## super - 부모 참조   
부모와 자식의 필드명이 같거나, 메서드가 오버라이딩(재정의)되어 있다면, 자식에서 부모의 필드나 메서드를 호출 할 수 없다.
이때 super 키워드를 사용하면 부모를 참조할 수 있다.
- this : 자기 자신
- super : 부모

### super - 생성자
상속 관계에서 인스턴스를 생성하면 부모자식 각각 만들어진다.  
**상속 관계를 사용하면 자식 클래스의 생성자에서 부모 클래스의 생성자를 반드시 호출해야 한다.**
> 다른 생성자를 정의하지 않으면 기본 생성자를 자바가 만들어주기 때문에 ```super()```를 생략해도 된다(자바가 자동으로 넣어줌).   하지만 정의한 생성자가 있다면 ```super(...)```을 반드시 추가해야 함  
> 생성자가 여러개 있다면, 생성자는 하나만 호출 할 수 있다. 따라서 하나를 선택하면 된다.

생성자의 실행 순서는 최상위 부모부터 실행되어 하나씩 내려온다.
왜냐하면 자식 생성자의 첫줄에서 부모의 생성자를 호출해야하기 때문이다.
> 메서드의 호출 순서는 처음 호출한 자식 생성자에서 시작하지만, 그 안에서 super()로 부모 호출을 하나씩 올라가게 된다. 따라서 초기화는 최상위에서 내려오게 됨

예외로 생성자 첫줄에 this()를 쓸 수 있다. 하지만 결국 언젠가는 super()를 호출해야 한다.
