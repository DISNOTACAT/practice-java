# 기본형의 한계

기본형은 객체가 아니기 때문에 다음과 같은 문제가 있다.
- 객체가 아님 : 객체지향프로그래밍의 장점을 이끌어 낼 수 없다. (ex.메서드 불가)
- null 값을 가질 수 없음 : 기본형은 항상 값을 가져야 한다. 하지만 때로는 데이터 `없음`을 표현해야 한다.

> `int`를 가지고 있는 클래스를 만들어 내면, 감싼 클래스를 만들 수 있다. 이것이 래퍼클래스이다.


# 래퍼클래스
- 불변이다.
- `equals`로 비교해야 한다.

### 박싱 (Boxing) & 언박싱
기본형을 래퍼클래스로 만드는 것 <-> 기본형으로 꺼내는 것
> `Integer` : -128 ~ 127의 자주 사용하는 숫자값 재사용

> 자바 1.5부터 '오토 박싱/언박싱' 기능을 제공 한다.


## 주요 메서드와 성능
- valueOf()
- parseInt()
- compareTo()
- Integer.sum(), Integer.min(),...

기본형은 연산이 래퍼 클래스보다 빠르다. 래퍼 클래스는 인스턴스로 기본형보다 많은 메모리를 차지하기 때문이다.

> **기본형 vs 래퍼 클래스 어떤거 사용?**  
> 일반적 애플리케이션 관점에서, 이런 부분을 최적화 화면 사막의 모래알의 차이일 뿐이다.  
> CPU 연산을 아주 많이 수행하는 특수한 환경이나, 수만-수십만 이상 연속 연산의 경우에는 기본형 사용을 고려할 수 있다.  
> 그렇지 않은 일반적인 경우라면 코드를 유지보수하기 더 나은 것을 선택하면 된다.


### 유지보수 vs 최적화
유지보수하기 좋은 코드를 먼저 고민해야 한다.

성능 최적화는 대부분 단순함 보다는 복잡함을 요구하고, 더 많은 코드를 만들어야 한다.
전체 애플리케이션의 성능 관점에서는 불필요한 최적화일 가능성이 있다.

특히 웹 애플리케이션의 경우 메모리 안에서 발생하는 연산 하나 보다 네트워크 호출 한번이 많ㅇ게는 수십만배 오래 걸린다.
권장하는 방법은 유지보수 하기 좋은 개발 이후 성능 테스트를 해보고 정말 문제가 되는 부분을 찾아서 최적화 하는 것이다.


# Class 클래스
자바에서 Class 클래스는 메타데이터를 다루는데 사용된다.
- **타입 정보 얻기** : 클래스의 이름, 슈퍼 클래스, 인스턴스, 접근 제한자 등과 같은 정보를 조회
- **리플렉션** : 클래스에 정의된 메소드, 필드, 생성자 등을 조회하고 이를 통해 인스턴스를 생성하거나 메소드를 호출하는 등의 작업을 수행할 수 있다.
- **동적 로딩과 생성** : `Class.forName()` 메서드를 사용하여 클래스를 동적으로 로드하고, `newInstance()` 메서드를 통해 새로운 인스턴스를 생성할 수 있다.
- **애노테이션 처리** : 클래스에 적용된 애노테이션을 조회하고 처리하는 기능

> `class` 는 자바의 예약어다. 자바 개발자는 `clazz`라는 이름을 관행으로 사용한다.

- 클래스 조회
```java
Class clazz = String.class; // 1. 클래스에서 조회
Class class = new String().getClass(); // 2. 인스턴스에서 조회
Class class = Class.forName("java.lang.String") // 3. 문자열로 조회
```

- getDeclareFields() : 클래스의 모든 필드 조회
- getDeclaredMethods() : 클래스의 모든 메서드 조회
- getSuperclass() : 클래스의 부모 클래스 조회
- getInterfaces() : 클래스의 인터페이스들을 조회


- **getDeclaredConstructor().newInstance()**
  - 1. 생성자를 선택
  - 2. 선택된 생성자를 기반으로 인스턴스를 생성

### 리플렉션 reflection
Class를 사용하면 클래스의 메타 정보를 기반으로 클래스에 정의된 메소드, 필드, 생성자 등을 조회하고, 이들을 통해 객체 인스턴스를 생성하거나 메소드를 호출하는 작업을 할 수 있다. 이런 작업을 리플렉션이라고 한다.
추가로 애노테이션 정보를 읽어서 특별한 기능을 수행할 수도 있다.


# System 클래스
- 표준입력, 출력, 오류 스트림 : `System.in`, `System.out`, `System.err`
- 시간 측정 : `System.currentTimeMillis()`, `System.nanoTime()`
- 환경 변수 : `System.getenv()`
- 시스템 속성(자바에서 사용하는 설정값) : `System.getProperties()`, 특정속성 : `System.getProperty(String key)`
- 시스템 종료(비권장) : `System.exit(int status)` 프로그램을 종료하고, OS에 프로그램 종료의 상태 코드를 전달
  - 0 : 정상종료
  - 그 외 : 오류나 예외적인 종료
- 배열 고속 복사 : `System.arraycopy` 시스템 레벨에서 최적화된 메모리 복사 연산


# Math, Random 클래스

> Random은 seed 값을 활용한다. seed 값이 같으면 같은 수가 나온다.

```java
import java.util.Random;

Random random = new Random(1); // seed가 같으면 Random의 결과가 같다.
int randomInt = random.nextInt(9); // 범위
System.out.println(randomInt);
```

`new Random()` 생성자를 비워두면 내부에서 `System.nanoTime()`에 여러가지 알고리즘을 섞어서 씨드값을 생성한다. 따라서 반복 실행해도 결과가 항상 달라진다.
`new Random(int seed)` 생성자에 씨드값을 전달할 수 있다. 씨드 값이 같으면 랜덤값을 구할 수 없다. 하지만 결과가 고정되기 때문에 테스트 코드 같은 곳에서 같은 결과를 검증할 수 있다.  
참고로 마인크래프트 같은 게임은 시작할 때 지형을 랜덤으로 생성하는데, 같은 씨드값을 설정하면 같은 지형을 생성할 수 있다.

